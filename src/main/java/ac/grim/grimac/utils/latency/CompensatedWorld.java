package ac.grim.grimac.utils.latency;

import ac.grim.grimac.GrimAPI;
import ac.grim.grimac.player.GrimPlayer;
import ac.grim.grimac.utils.blockdata.WrappedBlockData;
import ac.grim.grimac.utils.blockdata.types.*;
import ac.grim.grimac.utils.blockstate.BaseBlockState;
import ac.grim.grimac.utils.blockstate.FlatBlockState;
import ac.grim.grimac.utils.blockstate.MagicBlockState;
import ac.grim.grimac.utils.chunkdata.BaseChunk;
import ac.grim.grimac.utils.chunkdata.fifteen.FifteenChunk;
import ac.grim.grimac.utils.chunkdata.seven.SevenChunk;
import ac.grim.grimac.utils.chunkdata.sixteen.SixteenChunk;
import ac.grim.grimac.utils.chunkdata.twelve.TwelveChunk;
import ac.grim.grimac.utils.chunks.Column;
import ac.grim.grimac.utils.collisions.datatypes.SimpleCollisionBox;
import ac.grim.grimac.utils.data.*;
import ac.grim.grimac.utils.data.packetentity.PacketEntity;
import ac.grim.grimac.utils.data.packetentity.PacketEntityShulker;
import ac.grim.grimac.utils.enums.EntityType;
import ac.grim.grimac.utils.lists.EvictingList;
import ac.grim.grimac.utils.math.GrimMath;
import ac.grim.grimac.utils.nmsImplementations.Collisions;
import ac.grim.grimac.utils.nmsImplementations.GetBoundingBox;
import ac.grim.grimac.utils.nmsImplementations.Materials;
import ac.grim.grimac.utils.nmsImplementations.XMaterial;
import io.github.retrooper.packetevents.utils.pair.Pair;
import io.github.retrooper.packetevents.utils.player.ClientVersion;
import io.github.retrooper.packetevents.utils.server.ServerVersion;
import io.github.retrooper.packetevents.utils.vector.Vector3i;
import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import org.bukkit.Material;
import org.bukkit.block.BlockFace;

import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListSet;

// Inspired by https://github.com/GeyserMC/Geyser/blob/master/connector/src/main/java/org/geysermc/connector/network/session/cache/ChunkCache.java
public class CompensatedWorld {
    public static BaseBlockState airData;
    public static Method getByCombinedID;
    public final GrimPlayer player;
    public final EvictingList<TransPosData> posToTrans = new EvictingList<>(3);
    private final Map<Long, Column> chunks;
    public ConcurrentSkipListSet<BasePlayerChangeBlockData> worldChangedBlockQueue = new ConcurrentSkipListSet<>((a, b) -> {
        // We can't have elements with equal comparisons, otherwise they won't be added
        if (a.transaction == b.transaction) {
            boolean aOpenBlock = a instanceof PlayerOpenBlockData;
            boolean bOpenBlock = b instanceof PlayerOpenBlockData;

            if (aOpenBlock != bOpenBlock) return Boolean.compare(aOpenBlock, bOpenBlock);

            return Integer.compare(a.hashCode(), b.hashCode());
        }
        return Integer.compare(a.transaction, b.transaction);
    });
    public ConcurrentLinkedQueue<Pair<Integer, Vector3i>> unloadChunkQueue = new ConcurrentLinkedQueue<>();
    public ConcurrentLinkedQueue<PistonData> pistonData = new ConcurrentLinkedQueue<>();
    public ConcurrentLinkedQueue<Pair<Integer, Vector3i>> likelyDesyncBlockPositions = new ConcurrentLinkedQueue<>();
    // Packet locations for blocks
    public ConcurrentLinkedQueue<Pair<Integer, Vector3i>> packetLevelBlockLocations = new ConcurrentLinkedQueue<>();
    public List<PistonData> activePistons = new ObjectArrayList<>();
    public Set<ShulkerData> openShulkerBoxes = ConcurrentHashMap.newKeySet();
    public boolean isResync = false;
    // 1.17 with datapacks, and 1.18, have negative world offset values
    private int minHeight = 0;
    private int maxHeight = 255;

    public CompensatedWorld(GrimPlayer player) {
        this.player = player;
        chunks = Long2ObjectMaps.synchronize(new Long2ObjectOpenHashMap<>(81, 0.5f));
    }

    public static void init() {
        if (XMaterial.isNewVersion()) {
            airData = new FlatBlockState(0);
        } else {
            airData = new MagicBlockState(0, 0);
        }
    }

    public static long chunkPositionToLong(int x, int z) {
        return ((x & 0xFFFFFFFFL) << 32L) | (z & 0xFFFFFFFFL);
    }

    public boolean isNearHardEntity(SimpleCollisionBox playerBox) {
        synchronized (player.compensatedEntities.entityMap) {
            for (PacketEntity entity : player.compensatedEntities.entityMap.values()) {
                if (entity.type == EntityType.BOAT || entity.type == EntityType.SHULKER) {
                    SimpleCollisionBox box = GetBoundingBox.getBoatBoundingBox(entity.position.getX(), entity.position.getY(), entity.position.getZ());
                    if (box.isIntersected(playerBox)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public void tickUpdates(int lastTransactionReceived) {
        while (true) {
            Pair<Integer, Vector3i> data = unloadChunkQueue.peek();

            if (data == null) break;

            // The player hasn't gotten this update yet
            if (data.getFirst() > lastTransactionReceived) {
                break;
            }

            unloadChunkQueue.poll();

            int chunkX = data.getSecond().getX();
            int chunkZ = data.getSecond().getZ();

            long chunkPosition = chunkPositionToLong(chunkX, chunkZ);

            // Don't unload the chunk if this is a different chunk than what we actually wanted.
            Column loadedChunk = getChunk(chunkX, chunkZ);
            if (loadedChunk != null && loadedChunk.transaction < data.getFirst()) {
                chunks.remove(chunkPosition);
                openShulkerBoxes.removeIf(box -> box.position.getX() >> 4 == chunkX && box.position.getZ() >> 4 == chunkZ);
            }
        }

        for (Iterator<BasePlayerChangeBlockData> it = worldChangedBlockQueue.iterator(); it.hasNext(); ) {
            BasePlayerChangeBlockData changeBlockData = it.next();
            if (changeBlockData.transaction > lastTransactionReceived) {
                break;
            }

            it.remove();

            if (changeBlockData instanceof PlayerChangeBlockData || changeBlockData instanceof PlayerOpenBlockData) {
                likelyDesyncBlockPositions.add(new Pair<>(player.lastTransactionSent.get(), new Vector3i(changeBlockData.blockX, changeBlockData.blockY, changeBlockData.blockZ)));
            }

            if (changeBlockData instanceof PlayerOpenBlockData) {
                tickOpenable((PlayerOpenBlockData) changeBlockData);
                continue;
            }

            player.compensatedWorld.updateBlock(changeBlockData.blockX, changeBlockData.blockY, changeBlockData.blockZ, changeBlockData.getCombinedID());
        }

        while (true) {
            PistonData data = pistonData.peek();

            if (data == null) break;

            // The player hasn't gotten this update yet
            if (data.lastTransactionSent > lastTransactionReceived) {
                break;
            }

            pistonData.poll();
            activePistons.add(data);
        }

        // 3 ticks is enough for everything that needs to be processed to be processed
        likelyDesyncBlockPositions.removeIf(data -> player.packetStateData.packetLastTransactionReceived.get() > data.getFirst());
        packetLevelBlockLocations.removeIf(data -> GrimAPI.INSTANCE.getTickManager().getTick() - data.getFirst() > 3);
    }

    public boolean hasPacketBlockAt(SimpleCollisionBox box) {
        for (Pair<Integer, Vector3i> block : packetLevelBlockLocations) {
            Vector3i pos = block.getSecond();

            if (pos.getX() >= box.minX && pos.getX() <= box.maxX &&
                    pos.getY() >= box.minY && pos.getY() <= box.maxY &&
                    pos.getZ() >= box.minZ && pos.getZ() <= box.maxZ)
                return true;
        }

        return false;
    }

    public void updateBlock(int x, int y, int z, int combinedID) {
        Column column = getChunk(x >> 4, z >> 4);

        // Apply 1.17 expanded world offset
        y -= minHeight;

        try {
            if (column != null) {
                BaseChunk chunk = column.getChunks()[y >> 4];

                if (chunk == null) {
                    if (ServerVersion.getVersion().isNewerThanOrEquals(ServerVersion.v_1_16)) {
                        column.getChunks()[y >> 4] = new SixteenChunk();
                    } else if (ServerVersion.getVersion().isNewerThanOrEquals(ServerVersion.v_1_13)) {
                        column.getChunks()[y >> 4] = new FifteenChunk();
                    } else if (ServerVersion.getVersion().isNewerThanOrEquals(ServerVersion.v_1_8)) {
                        column.getChunks()[y >> 4] = new TwelveChunk();
                    } else {
                        column.getChunks()[y >> 4] = new SevenChunk();
                    }

                    chunk = column.getChunks()[y >> 4];

                    // Sets entire chunk to air
                    // This glitch/feature occurs due to the palette size being 0 when we first create a chunk section
                    // Meaning that all blocks in the chunk will refer to palette #0, which we are setting to air
                    chunk.set(0, 0, 0, 0);
                }

                chunk.set(x & 0xF, y & 0xF, z & 0xF, combinedID);
            }
        } catch (Exception ignored) {
        }
    }

    public void tickOpenable(PlayerOpenBlockData blockToOpen) {
        MagicBlockState data = (MagicBlockState) player.compensatedWorld.getWrappedBlockStateAt(blockToOpen.blockX, blockToOpen.blockY, blockToOpen.blockZ);
        WrappedBlockDataValue blockDataValue = WrappedBlockData.getMaterialData(data);

        if (blockDataValue instanceof WrappedDoor) {
            WrappedDoor door = (WrappedDoor) blockDataValue;
            MagicBlockState otherDoor = (MagicBlockState) player.compensatedWorld.getWrappedBlockStateAt(blockToOpen.blockX, blockToOpen.blockY + (door.isBottom() ? 1 : -1), blockToOpen.blockZ);

            // The doors seem connected (Remember this is 1.12- where doors are dependent on one another for data
            if (otherDoor.getMaterial() == data.getMaterial()) {
                // The doors are probably connected
                boolean isBottom = door.isBottom();
                // Add the other door part to the likely to desync positions
                player.compensatedWorld.likelyDesyncBlockPositions.add(new Pair<>(player.lastTransactionSent.get(), new Vector3i(blockToOpen.blockX, blockToOpen.blockY + (isBottom ? 1 : -1), blockToOpen.blockZ)));
                // 1.12- stores door data in the bottom door
                if (!isBottom)
                    data = otherDoor;
                // 1.13+ - We need to grab the bukkit block data, flip the open state, then get combined ID
                // 1.12- - We can just flip a bit in the lower door and call it a day
                int magicValue = data.getId() | ((data.getBlockData() ^ 0x4) << 12);
                player.compensatedWorld.updateBlock(blockToOpen.blockX, blockToOpen.blockY + (isBottom ? 0 : -1), blockToOpen.blockZ, magicValue);
            }
        } else if (blockDataValue instanceof WrappedTrapdoor || blockDataValue instanceof WrappedFenceGate) {
            // Take 12 most significant bytes -> the material ID.  Combine them with the new block magic data.
            int magicValue = data.getId() | ((data.getBlockData() ^ 0x4) << 12);
            player.compensatedWorld.updateBlock(blockToOpen.blockX, blockToOpen.blockY, blockToOpen.blockZ, magicValue);
        }
    }

    public void tickPlayerInPistonPushingArea() {
        player.uncertaintyHandler.tick();
        // Occurs on player login
        if (player.boundingBox == null) return;
        SimpleCollisionBox playerBox = player.boundingBox.copy().expand(0.03);

        for (PistonData data : activePistons) {
            double modX = 0;
            double modY = 0;
            double modZ = 0;

            for (SimpleCollisionBox box : data.boxes) {
                if (playerBox.isCollided(box)) {
                    modX = Math.abs(data.direction.getModX()) * 0.51D;
                    modY = Math.abs(data.direction.getModY()) * 0.51D;
                    modZ = Math.abs(data.direction.getModZ()) * 0.51D;

                    playerBox.expandMax(modX, modY, modZ);
                    playerBox.expandMin(modX * -1, modY * -1, modZ * -1);

                    if (data.hasSlimeBlock || (data.hasHoneyBlock && player.getClientVersion().isOlderThan(ClientVersion.v_1_15_2))) {
                        player.uncertaintyHandler.slimePistonBounces.add(data.direction);
                    }

                    break;
                }
            }

            player.uncertaintyHandler.pistonX = Math.max(modX, player.uncertaintyHandler.pistonX);
            player.uncertaintyHandler.pistonY = Math.max(modY, player.uncertaintyHandler.pistonY);
            player.uncertaintyHandler.pistonZ = Math.max(modZ, player.uncertaintyHandler.pistonZ);
        }

        for (ShulkerData data : openShulkerBoxes) {
            double modX = 0;
            double modY = 0;
            double modZ = 0;

            SimpleCollisionBox shulkerCollision = new SimpleCollisionBox(data.position.getX(), data.position.getY(), data.position.getZ(),
                    data.position.getX() + 1, data.position.getY() + 1, data.position.getZ() + 1, true);

            BlockFace direction;
            if (data.entity == null) {
                BaseBlockState state = player.compensatedWorld.getWrappedBlockStateAt(data.position.getX(), data.position.getY(), data.position.getZ());
                WrappedBlockDataValue value = WrappedBlockData.getMaterialData(state);

                // This is impossible but I'm not willing to take the risk
                if (!(value instanceof WrappedDirectional)) continue;

                direction = ((WrappedDirectional) value).getDirection();
            } else {
                direction = ((PacketEntityShulker) data.entity).facing.getOppositeFace();
            }

            // Change negative corner in expansion as the direction is negative
            // We don't bother differentiating shulker entities and shulker boxes
            // I guess players can cheat to get an extra 0.49 of Y height on shulker boxes, I don't care.
            if (direction.getModX() == -1 || direction.getModY() == -1 || direction.getModZ() == -1) {
                shulkerCollision.expandMin(direction.getModX(), direction.getModY(), direction.getModZ());
            } else {
                shulkerCollision.expandMax(direction.getModZ(), direction.getModY(), direction.getModZ());
            }

            if (playerBox.isCollided(shulkerCollision)) {
                modX = Math.abs(direction.getModX());
                modY = Math.abs(direction.getModY());
                modZ = Math.abs(direction.getModZ());

                playerBox.expandMax(modX, modY, modZ);
                playerBox.expandMin(modX, modY, modZ);
            }

            player.uncertaintyHandler.pistonX = Math.max(modX, player.uncertaintyHandler.pistonX);
            player.uncertaintyHandler.pistonY = Math.max(modY, player.uncertaintyHandler.pistonY);
            player.uncertaintyHandler.pistonZ = Math.max(modZ, player.uncertaintyHandler.pistonZ);
        }

        if (activePistons.isEmpty() && openShulkerBoxes.isEmpty()) {
            player.uncertaintyHandler.pistonX = 0;
            player.uncertaintyHandler.pistonY = 0;
            player.uncertaintyHandler.pistonZ = 0;
        }

        // Reduce effects of piston pushing by 0.5 per tick
        player.uncertaintyHandler.pistonPushing.add(Math.max(Math.max(player.uncertaintyHandler.pistonX, player.uncertaintyHandler.pistonY), player.uncertaintyHandler.pistonZ) * (player.uncertaintyHandler.slimePistonBounces.isEmpty() ? 1 : 2));

        // Tick the pistons and remove them if they can no longer exist
        activePistons.removeIf(PistonData::tickIfGuaranteedFinished);
        openShulkerBoxes.removeIf(ShulkerData::tickIfGuaranteedFinished);
    }

    public BaseBlockState getWrappedBlockStateAt(int x, int y, int z) {
        Column column = getChunk(x >> 4, z >> 4);
        if (column == null || y < minHeight || y > maxHeight) return airData;

        y -= minHeight;

        try {
            BaseChunk chunk = column.getChunks()[y >> 4];
            if (chunk != null) {
                return chunk.get(x & 0xF, y & 0xF, z & 0xF);
            }
        } catch (Exception ignored) {
        }

        return airData;
    }

    public Column getChunk(int chunkX, int chunkZ) {
        long chunkPosition = chunkPositionToLong(chunkX, chunkZ);
        return chunks.get(chunkPosition);
    }

    public boolean isChunkLoaded(int chunkX, int chunkZ) {
        long chunkPosition = chunkPositionToLong(chunkX, chunkZ);

        return chunks.containsKey(chunkPosition);
    }

    public void addToCache(Column chunk, int chunkX, int chunkZ) {
        long chunkPosition = chunkPositionToLong(chunkX, chunkZ);

        chunks.put(chunkPosition, chunk);
    }

    public Material getBukkitMaterialAt(double x, double y, double z) {
        return getWrappedBlockStateAt((int) Math.floor(x), (int) Math.floor(y), (int) Math.floor(z)).getMaterial();
    }

    public BaseBlockState getWrappedBlockStateAt(double x, double y, double z) {
        return getWrappedBlockStateAt((int) Math.floor(x), (int) Math.floor(y), (int) Math.floor(z));
    }

    public double getFluidLevelAt(double x, double y, double z) {
        return getFluidLevelAt((int) Math.floor(x), (int) Math.floor(y), (int) Math.floor(z));
    }

    public double getFluidLevelAt(int x, int y, int z) {
        return Math.max(getWaterFluidLevelAt(x, y, z), getLavaFluidLevelAt(x, y, z));
    }

    public boolean isFluidFalling(int x, int y, int z) {
        MagicBlockState bukkitBlock = (MagicBlockState) getWrappedBlockStateAt(x, y, z);
        return ((bukkitBlock.getBlockData() & 0x8) == 8);
    }

    public boolean isWaterSourceBlock(int x, int y, int z) {
        BaseBlockState bukkitBlock = getWrappedBlockStateAt(x, y, z);
        return ((MagicBlockState) bukkitBlock).getBlockData() == 0;
    }

    public boolean containsLiquid(SimpleCollisionBox var0) {
        return Collisions.hasMaterial(player, var0, data -> Materials.isWater(player.getClientVersion(), data) || Materials.checkFlag(data.getMaterial(), Materials.LAVA));
    }

    public boolean containsWater(SimpleCollisionBox var0) {
        return Collisions.hasMaterial(player, var0, data -> Materials.isWater(player.getClientVersion(), data));
    }

    public double getLavaFluidLevelAt(int x, int y, int z) {
        MagicBlockState magicBlockState = (MagicBlockState) getWrappedBlockStateAt(x, y, z);

        if (!Materials.checkFlag(magicBlockState.getMaterial(), Materials.LAVA)) return 0;

        // If it is lava or flowing lava
        if (magicBlockState.getId() == 10 || magicBlockState.getId() == 11) {
            int magicData = magicBlockState.getBlockData();

            // Falling lava has a level of 8
            if ((magicData & 0x8) == 8) return 8 / 9f;

            return (8 - magicData) / 9f;
        }

        return 0;
    }

    public boolean containsLava(SimpleCollisionBox var0) {
        return Collisions.hasMaterial(player, var0, data -> Materials.checkFlag(data.getMaterial(), Materials.LAVA));
    }

    public double getWaterFluidLevelAt(double x, double y, double z) {
        return getWaterFluidLevelAt(GrimMath.floor(x), GrimMath.floor(y), GrimMath.floor(z));
    }

    public double getWaterFluidLevelAt(int x, int y, int z) {
        BaseBlockState bukkitBlock = getWrappedBlockStateAt(x, y, z);
        boolean isWater = Materials.isWaterIgnoringWaterlogged(player.getClientVersion(), bukkitBlock);

        if (!isWater) return 0;

        // If water has water above it, it's block height is 1, even if it's waterlogged
        if (Materials.isWaterIgnoringWaterlogged(player.getClientVersion(), getWrappedBlockStateAt(x, y + 1, z))) {
            return 1;
        }

        MagicBlockState magicBlockState = (MagicBlockState) bukkitBlock;

        // If it is water or flowing water
        if (magicBlockState.getId() == 8 || magicBlockState.getId() == 9) {
            int magicData = magicBlockState.getBlockData();

            // Falling water has a level of 8
            if ((magicData & 0x8) == 8) return 8 / 9f;

            return (8 - magicData) / 9f;
        }

        return 0;
    }

    public void removeChunkLater(int chunkX, int chunkZ) {
        long chunkPosition = chunkPositionToLong(chunkX, chunkZ);
        Column column = chunks.get(chunkPosition);

        if (column == null) return;

        // Signify that there could be a desync between this and netty
        column.markedForRemoval = true;
        unloadChunkQueue.add(new Pair<>(player.lastTransactionSent.get() + 1, new Vector3i(chunkX, 0, chunkZ)));
    }

    public void setMaxWorldHeight(int maxSectionHeight) {
        if (maxSectionHeight % 16 != 0) {
            throw new RuntimeException("Maximum world height must be a multiple of 16!");
        }

        this.maxHeight = maxSectionHeight;
    }

    public int getMinHeight() {
        return minHeight;
    }

    public void setMinHeight(int minHeight) {
        if (minHeight % 16 != 0) {
            throw new RuntimeException("Minimum world height must be a multiple of 16!");
        }

        this.minHeight = minHeight;
    }

    public int getMaxHeight() {
        return maxHeight;
    }
}
